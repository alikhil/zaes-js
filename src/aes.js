"use strict";

/**
 * Advanced Encryption Standard (AES) implementation
 * 
 * This implementation based on aes.js from `sttp` project 
 * which was written by Sergey Strokov <Sergey_umnov@mail.ru>
 * 
 * @author Alik Khilazhev 
 */



const WORD_LENGTH = 4;
const COLUMNS = 4;

import {subWord, xorWords, rotWordLeft} from "./aes-utils";
import * as a_u from "./aes-utils";

const secureRandom = require("secure-random");

function isKeyLengthValid(length) {
    return length === 16 ||
        length === 24 ||
        length === 32; 
}

function splitToMatrix(block)
{
    let state = new Array(4);
    for (let i = 0; i < 4; i++) {
        state[i] = block.slice(i * COLUMNS, (i + 1) * COLUMNS);
    }
    return state;
}

function getRoundsCount(key) {
    switch(key.length) {
        case 16:
            return 10;
        case 24:
            return 12;
        case 32:
            return 14;
        default:
            throw new Error("invalid key length");
    }
}

/**
 * Generates keys for each round
 */
function expandKey(key) {
    let tempWord = new Array(WORD_LENGTH);
    let rounds = getRoundsCount(key);
    let wordsCount = key.length / WORD_LENGTH;
    let keySchedule = new Array(COLUMNS * (rounds + 1));
    
    for (let i = 0; i < wordsCount; i++) {
        keySchedule[i] = key.slice(WORD_LENGTH * i, WORD_LENGTH * i + WORD_LENGTH);
    }
    for (let i = wordsCount; i < keySchedule.length; i++) {
        tempWord = keySchedule[i - 1];
        if (i % wordsCount === 0) {
            tempWord = xorWords(subWord(rotWordLeft(tempWord)), a_u.R_CON[i / wordsCount]);
        } else if (wordsCount > 6 && i % wordsCount === 4) {
            tempWord = subWord(tempWord);
        }
        keySchedule[i] = xorWords(keySchedule[i - wordsCount], tempWord);
    }
    return keySchedule;
}

/**
 * Generates random aes key of given length
 * @param length length of key. 16, 24 or 32 bytes
 * @returns {*} array of bytes of given length
 * @throws Error if given invalid key length
 */
export function generateKey(length) {
    if (!isKeyLengthValid(length)) {
        throw new Error("invalid key length");
    }
    let array = secureRandom(length);
    return array;
}

/**
 * Encrypts given block
 */
function encryptBlock(block, keySchedule) {
    let state = splitToMatrix(block);

    state = a_u.addRoundKey(state, keySchedule.slice(0, 4));
    let rounds = keySchedule.length / COLUMNS;
    for (let round = 1; round < rounds; round++){
        state = a_u.subBytes(state);
        state = a_u.shiftRows(state);
        state = a_u.mixColumns(state);
        state = a_u.addRoundKey(state, keySchedule.slice(round * COLUMNS, (round + 1) * COLUMNS));
    }
    state = a_u.subBytes(state);
    state = a_u.shiftRows(state);
    state = a_u.addRoundKey(state, keySchedule.slice(COLUMNS * (rounds-1), COLUMNS * rounds));    
    
    let encryptedBlock = new Array(a_u.BLOCK_LENGTH);
    for (let i = 0; i < state.length; i++) {
        for (let j = 0; j < state[i].length; j++) {
            encryptedBlock[4 * i + j] = state[i][j];
        }
    } 
    return encryptedBlock;
}

/**
 * Encrypts array of bytes of any length with given key. 
 * @param bytes Array of bytes
 * @param key AES key generated by generateKey function, should have length 16, 24 or 32
 * @throws Error if given invalid key
 */
export function encrypt(bytes, key) {
    if (!isKeyLengthValid(key.length)) {
        throw new Error("invalid key length");
    }
    let keySchedule = expandKey(key);
    let normalizedArray = a_u.normalize(bytes);
    let blocks = a_u.splitArray(normalizedArray);
    let encryptedBlocks = new Array(blocks.length);
    for (let i = 0; i < blocks.length; i++) {
        encryptedBlocks[i] = encryptBlock(blocks[i], keySchedule);
    }
    return a_u.joinArray(encryptedBlocks);
}



function decryptBlock(block, keySchedule) {
    let state = splitToMatrix(block);
    state = a_u.addRoundKey(state, keySchedule.slice(40, 44));
    let rounds = keySchedule.length / COLUMNS;
    for (let round = rounds - 1; round > 0; round--) {
        state = a_u.invShiftRows(state);
        state = a_u.invSubBytes(state);
        state = a_u.addRoundKey(state, keySchedule.slice(round * COLUMNS, (round + 1) * COLUMNS));
        state = a_u.invMixColumns(state);
    }

    state = a_u.invShiftRows(state);
    state = a_u.invSubBytes(state);
    state = a_u.addRoundKey(state, keySchedule.slice(0, COLUMNS));

    let decryptedBlock = new Array(a_u.BLOCK_LENGTH);
    
    for (let i = 0; i < state.length; i++) {
        for (let j = 0; j < state[i].length; j++) {
            decryptedBlock[4 * i + j] = state[i][j];
        }
    }
    return decryptedBlock;

}

export function decrypt(byteArray, key) {
    let blocks = a_u.splitArray(byteArray);
    let keySchedule = expandKey(key);
    let plain = new Array(blocks.length);
    for (let i = 0; i < blocks.length; i++) {
        plain[i] = decryptBlock(blocks[i], keySchedule);
    }
    let decryptedArray = a_u.joinArray(plain);
    
    return a_u.deleteSpaces(decryptedArray);
}