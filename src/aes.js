"use strict";

/**
 * Advanced Encryption Standard (AES) implementation
 * 
 * This implementation based on aes.js from `sttp` project 
 * which was written by Sergey Strokov <Sergey_umnov@mail.ru>
 * 
 * @author Alik Khilazhev 
 */



const WORD_LENGTH = 4;
const COLUMNS = 4;

const a_u = require("./aes-utils");

const secureRandom = require("secure-random");

function isKeyLengthValid(length) {
	return length === 16 ||
		length === 24 ||
		length === 32; 
}

function splitToMatrix(block)
{
	let state = new Array(4);
	for (let i = 0; i < 4; i++) {
		state[i] = block.slice(i * COLUMNS, (i + 1) * COLUMNS);
	}
	return state;
}

function getRoundsCount(key) {
	switch(key.length) {
	case 16:
		return 10;
	case 24:
		return 12;
	case 32:
		return 14;
	default:
		throw new Error("invalid key length");
	}
}

function getBlockFromState(state) {
	let block = new Array(a_u.BLOCK_LENGTH);
	for (let i = 0; i < state.length; i++) {
		for (let j = 0; j < state[i].length; j++) {
			block[4 * i + j] = state[i][j];
		}
	} 
	return block;
}

function applyActionToBlocks(action, blocks, keySchedule) {
	let newBlocks = new Array(blocks.length);
	for (let i = 0; i < blocks.length; i++) {
		newBlocks[i] = action(blocks[i], keySchedule);
	}
	return newBlocks;
} 

/**
 * Generates keys for each round
 */
function expandKey(key) {
	let tempWord = new Array(WORD_LENGTH);
	let rounds = getRoundsCount(key);
	let wordsCount = key.length / WORD_LENGTH;
	let keySchedule = new Array(COLUMNS * (rounds + 1));
	
	for (let i = 0; i < wordsCount; i++) {
		keySchedule[i] = key.slice(WORD_LENGTH * i, WORD_LENGTH * i + WORD_LENGTH);
	}
	for (let i = wordsCount; i < keySchedule.length; i++) {
		tempWord = keySchedule[i - 1];
		if (i % wordsCount === 0) {
			tempWord = a_u.xorWords(a_u.subWord(a_u.rotWordLeft(tempWord)), a_u.R_CON[i / wordsCount]);
		} else if (wordsCount > 6 && i % wordsCount === 4) {
			tempWord = a_u.subWord(tempWord);
		}
		keySchedule[i] = a_u.xorWords(keySchedule[i - wordsCount], tempWord);
	}
	return keySchedule;
}

/**
 * Generates random aes key of given length
 * @param {number} length length of key. 16, 24 or 32 bytes
 * @returns {number[]} array of bytes of given length
 * @throws {Error} if given invalid key length
 */
module.exports.generateKey = function(length) {
	if (!isKeyLengthValid(length)) {
		throw new Error("invalid key length");
	}
	let array = secureRandom(length);
	return array;
};

/**
 * Encrypts given block
 */
function encryptBlock(block, keySchedule) {
	let state = splitToMatrix(block);

	state = a_u.addRoundKey(state, keySchedule.slice(0, 4));
	let rounds = keySchedule.length / COLUMNS;
	for (let round = 1; round < rounds; round++){
		state = a_u.subBytes(state);
		state = a_u.shiftRows(state);
		state = a_u.mixColumns(state);
		state = a_u.addRoundKey(state, keySchedule.slice(round * COLUMNS, (round + 1) * COLUMNS));
	}
	state = a_u.subBytes(state);
	state = a_u.shiftRows(state);
	state = a_u.addRoundKey(state, keySchedule.slice(COLUMNS * (rounds-1), COLUMNS * rounds));    
	
	return getBlockFromState(state);
}

/**
 * Encrypts array of bytes of any length with given key. 
 * @param {number[]} bytes Array of bytes
 * @param {number[]} key AES key generated by generateKey function, should have length 16, 24 or 32(128, 192 or 256 bits)
 * @throws {Error} if given invalid key
 * @returns {number[]} Encrypted array of bytes
 */
module.exports.encrypt = function(bytes, key) {
	if (!isKeyLengthValid(key.length)) {
		throw new Error("invalid key length");
	}
	let keySchedule = expandKey(key);
	let lastBlockLength = bytes.length % a_u.BLOCK_LENGTH;
	let normalizedArray = a_u.normalize(bytes);
	let blocks = a_u.splitArray(normalizedArray);
	let encryptedBlocks = applyActionToBlocks(encryptBlock, blocks, keySchedule);
	return [lastBlockLength].concat(a_u.joinArray(encryptedBlocks));
};



function decryptBlock(block, keySchedule) {
	let state = splitToMatrix(block);
	let kl = keySchedule.length;
	state = a_u.addRoundKey(state, keySchedule.slice(kl - 4, kl));
	let rounds = keySchedule.length / COLUMNS;
	for (let round = rounds - 1; round > 0; round--) {
		state = a_u.invShiftRows(state);
		state = a_u.invSubBytes(state);
		state = a_u.addRoundKey(state, keySchedule.slice(round * COLUMNS, (round + 1) * COLUMNS));
		state = a_u.invMixColumns(state);
	}

	state = a_u.invShiftRows(state);
	state = a_u.invSubBytes(state);
	state = a_u.addRoundKey(state, keySchedule.slice(0, COLUMNS));

	return getBlockFromState(state);

}

/**
 * Decrypts array of bytes using passed key.
 * @param {number[]} bytes Array of bytes
 * @param {number[]} key Key with which array is encrypted. Should have length 16, 24 or 32(128, 192 or 256 bits)
 * @throws {Error} if key is invalid
 * @returns {number[]} Decrypted array of bytes. 
 */
module.exports.decrypt = function(bytes, key) {
	let lastBlockLength = bytes[0];
	let blocks = a_u.splitArray(bytes.slice(1));
	let keySchedule = expandKey(key);
	let decryptedBlocks = applyActionToBlocks(decryptBlock, blocks, keySchedule);
	let decryptedArray = a_u.joinArray(decryptedBlocks);
	let trueLength = decryptedArray.length;
	if (lastBlockLength > 0) {
		trueLength = trueLength - a_u.BLOCK_LENGTH + lastBlockLength;
	}
	return decryptedArray.slice(0, trueLength);
};